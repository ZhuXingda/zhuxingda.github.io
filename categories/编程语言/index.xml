<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>编程语言 on Zhu Xingda</title>
    <link>https://blog.xingda.space/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/</link>
    <description>Recent content in 编程语言 on Zhu Xingda</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 10 Apr 2025 17:14:15 +0800</lastBuildDate>
    <atom:link href="https://blog.xingda.space/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Go 和 Java 在多线程、内存模型、垃圾回收上的对比</title>
      <link>https://blog.xingda.space/tech/golang_java_compare/</link>
      <pubDate>Thu, 10 Apr 2025 17:14:15 +0800</pubDate>
      <guid>https://blog.xingda.space/tech/golang_java_compare/</guid>
      <description>线程模型 1. JDK 19 以下 版本（排除最早的 Green Threads 老版本） 采用 1 ：1 的线程模型，即每个用户线程对应一个内核线程&#xA;线程的创建、销毁、切换都由操作系统的调度器完成，JVM 不参与 目前主流操作系统使用抢占式线程调度策略，当 JVM 线程阻塞时，比如 Object.wait()、Thread.sleep()、Thread.join()、LockSupport.park() 等导致线程进入 WAITING 或 TIMED_WAITING 状态，或者抢占 synchronized 锁时进入 BLOCKED 状态，线程都会释放 CPU，只有回到 RUNNABLE 状态后线程才能被系统调度器重新调度进入 RUNNING 状态 JVM 线程在遇到 I/O 阻塞时仍然保持 RUNNABLE 状态，但其对应的内核态线程会被操作系统挂起直到 I/O 操作完成 JVM 的最大线程数出了自身的配置外，还受限于 Linux Kernel 的线程数限制 JVM 的线程创和切换涉及用户态和内核态的切换、CPU 上下文切换，开销较大，通常采用线程池来减少线程创建的开销 2. JDK 19 及以上版本 参考资料 JDK 19 引入了 virtual thread 虚拟线程，采用 M：N 的线程模型，一个内核线程对应一个用户态的平台线程，一个平台线程对应多个虚拟线程&#xA;虚拟线程的调度、销毁、切换都由 JVM 完成，不需要操作系统调度器参与 JVM 对虚拟线程采用协作式线程调度策略，当线程阻塞时会主动从平台线程上卸载，让调度器调度其他线程运行 虚拟线程的最大线程数不受 Linux Kernel 的线程数限制，只受限于 JVM 的配置和系统内存，可以创建大量虚拟线程用以处理 I/O 密集型任务 虚拟线程的创建和切换都在用户态完成，避免了用户态和内核态的切换、CPU 上下文切换的开销 3.</description>
    </item>
  </channel>
</rss>
