<!DOCTYPE html>
<html class="no-js" lang="zh-cn">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Flink】Flink Watermark 产生和传递原理 - Zhu Xingda</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="上下而求索" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">上下而求索</div>
					<div class="logo__tagline">朱兴达的个人博客</div>
				</div>
		</a>
	</div>
		
<nav class="menu">
	<button class="menu__btn" aria-haspopup="true" aria-expanded="false" tabindex="0">
		<span class="menu__btn-title" tabindex="-1">菜单</span>
	</button>
	<ul class="menu__list">
		<li class="menu__item">
			<a class="menu__link" href="/">
				
				<span class="menu__text">主页</span>
				
			</a>
		</li>
		<li class="menu__item menu__item--active">
			<a class="menu__link" href="/tech/">
				
				<span class="menu__text">技术</span>
				
			</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="/note/">
				
				<span class="menu__text">笔记本</span>
				
			</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="">
				
				<span class="menu__text">生活</span>
				
			</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="/%E5%85%B3%E4%BA%8E%E6%88%91/">
				
				<span class="menu__text">关于我</span>
				
			</a>
		</li>
	</ul>
</nav>

	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Flink】Flink Watermark 产生和传递原理</h1>
			<div class="post__meta meta">
<div class="meta__item-datetime meta__item">
	<svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0a14 14 0 1 1 0 28 1 1 0 0 1 0-28m0 3a3 3 0 1 0 0 22 3 3 0 0 0 0-22m1 4h-2v8.4l6.8 4.4L22 18l-6-3.8z"/></svg><time class="meta__text" datetime="2025-03-25T19:27:37&#43;08:00">2025-03-25</time></div><div class="meta__item-categories meta__item"><svg class="meta__icon icon icon-category" width="16" height="16" viewBox="0 0 16 16"><path d="m7 2 1 2h8v11H0V2z"/></svg><span class="meta__text"><a class="meta__link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/" rel="category">分布式系统</a>
	</span>
</div></div>
		</header>
		
		
		<div class="content post__content clearfix">
			<p>Flink Watermark 的产生原理和传递过程</p>
<h2 id="1-产生-watermark">1. 产生 Watermark</h2>
<h4 id="11-定义-watermarkstrategy-并在创建-sourceoperator-时传入">1.1 定义 WatermarkStrategy 并在创建 SourceOperator 时传入</h4>
<p><strong>WatermarkStrategy</strong> 配置传入 SourceOperatorFactory</p>
<ol>
<li>StreamExecutionEnvironment#fromSource</li>
<li>DataStreamSource#DataStreamSource</li>
<li>SourceTransformation#SourceTransformation</li>
<li>SourceTransformationTranslator#translateInternal</li>
<li>SourceOperatorFactory#SourceOperaotorFactory</li>
<li>SourceOperatorFactory#createStreamOperator</li>
<li>SourceOperator#SourceOperator</li>
</ol>
<h4 id="12-初始化-sourceoperator-时创建-timestampsandwatermarks-对象">1.2 初始化 SourceOperator 时创建 TimestampsAndWatermarks 对象</h4>
<ol>
<li>SourceOperator#open</li>
<li>TimestampsAndWatermarks#createProgressiveEventTimeLogic<br>
TimestampsAndWatermarks 接口定义了时间戳提取和 watermark 生成</li>
<li>ProgressiveTimestampsAndWatermarks#ProgressiveTimestampsAndWatermarks</li>
<li>ProgressiveTimestampsAndWatermarks#startPeriodicWatermarkEmits</li>
<li>ProgressiveTimestampsAndWatermarks#triggerPeriodicEmit 如果 <code>pipeline.auto-watermark-interval</code> 配置不为 0 开启周期性触发 watermark</li>
</ol>
<h4 id="13-sourceoperator-在开始推送数据时创建-mainoutput-和-splitlocaloutput">1.3 SourceOperator 在开始推送数据时创建 MainOutput 和 SplitLocalOutput</h4>
<ol>
<li>SourceOperator#emitNext</li>
<li>SourceOperator#emitNextNotReading</li>
<li>SourceOperator#initializeMainOutput</li>
<li>TimestampsAndWatermarks#createMainOutput</li>
<li>ProgressiveTimestampsAndWatermarks#createMainOutput 创建 MainOutput 和 SplitLocalOutput</li>
</ol>
<h4 id="14-触发-mainoutput-周期性输出-watermark">1.4 触发 MainOutput 周期性输出 Watermark</h4>
<ol>
<li>ProgressiveTimestampsAndWatermarks#triggerPeriodicEmit</li>
<li>SourceOutputWithWatermarks#emitPeriodicWatermark</li>
<li>WatermarkGenerator#onPeriodicEmit</li>
<li>BoundedOutOfOrdernessWatermarks#onPeriodicEmit 回到 WatermarkStrategy 里配置的 WatermarkGenerator，调用定义输出 watermark</li>
<li>WatermarkOutput#emitWatermark</li>
</ol>
<h4 id="15-触发-splitlocaloutputs-周期性输出-watermark">1.5 触发 SplitLocalOutputs 周期性输出 Watermark</h4>
<ol>
<li>ProgressiveTimestampsAndWatermarks#triggerPeriodicEmit</li>
<li>SplitLocalOutputs#emitPeriodicWatermark<br>
2.1 SourceOutputWithWatermarks#emitPeriodicWatermark 后面的逻辑同 MainOutput<br>
2.2 WatermarkOutputMultiplexer#onPeriodicEmit <br>
2.3 WatermarkOutputMultiplexer#updateCombinedWatermark <br>
更新 combinedWatermark 并推送到 underlyingOutput<br>
2.3.1 CombinedWatermarkStatus#updateCombinedWatermark <br>
取所有 partialWatermarks 里的最小值作为 combinedWatermark<br>
2.3.2 WatermarkToDataOutput#emitWatermark<br>
2.3.3 PushingAsyncDataInput.DataOutput#emitWatermark <br>
将 watermark 推送到下游</li>
</ol>
<h4 id="16-datasource-触发-mainoutput-watermark-更新">1.6 DataSource 触发 MainOutput watermark 更新</h4>
<ol>
<li>SourceOutput#collect(T, long) 这里需要 DataSource 支持，在 <a href="../flink_source_api">【Flink】Data Source API 结构及实现</a> 里有介绍</li>
<li>SourceReaderBase.SourceOutputWrapper#collect(T, long)</li>
<li>SourceOutputWithWatermarks#collect(T, long) <br>
3.1 TimestampAssigner#extractTimestamp 根据定义从数据和传入的时间戳中提取 watermark<br>
3.1 PushingAsyncDataInput.DataOutput#emitRecord 先将带 watermark 的数据推送到下游<br>
3.2 WatermarkGenerator#onEvent <br>
3.2.1 BoundedOutOfOrdernessWatermarks#onEvent 更新最大的 watermark （以 BoundedOutOfOrdernessWatermarks 为例）</li>
</ol>
<h4 id="17-timestampsandwatermarksoperator-产生-watermark">1.7 TimestampsAndWatermarksOperator 产生 Watermark</h4>
<p>如果 watermark 的配置是通过 DataStream#assignTimestampsAndWatermarks 方法在 DataSource 之后配置的，Flink 会在 Source 的 OperatorChain 里创建 TimestampsAndWatermarksOperator 来处理 watermark 的生成和传递。</p>
<ol>
<li>TimestampsAndWatermarksOperator 继承了 ProcessingTimeService.ProcessingTimeCallback 接口，如果是流式任务 Operator 会循环注册定时器，时间间隔为 <code>pipeline.auto-watermark-interval</code>，每次触发都会调用会调用 <code>WatermarkGenerator#onPeriodicEmit</code> 接口</li>
<li>TimestampsAndWatermarksOperator 会完全忽略上游发送的 <code>WatermarkStatus</code>，但会将上游发送的 watermark 传递给下游</li>
<li>上游发送的 StreamRecord 在 TimestampsAndWatermarksOperator#processElement 方法里被替换成 TimestampAssigner 产生的新 timestamp，然后被传给 <code>WatermarkGenerator#onEvent</code> 接口更新 watermark</li>
</ol>
<h2 id="2-传递-watermark">2. 传递 Watermark</h2>
<ol>
<li>BoundedOutOfOrdernessWatermarks#onPeriodicEmit</li>
<li>WatermarkToDataOutput#emitWatermark</li>
<li>PushingAsyncDataInput.DataOutput#emitWatermark</li>
<li>Input#processWatermark</li>
<li>AbstractStreamOperator#processWatermark</li>
</ol>
<h4 id="21-timeservice-处理-watermark">2.1 TimeService 处理 Watermark</h4>
<ol>
<li>AbstractStreamOperator#processWatermark</li>
<li>InternalTimeServiceManager#advanceWatermark</li>
<li>InternalTimeServiceManagerImpl#advanceWatermark</li>
<li>InternalTimerServiceImpl#advanceWatermark</li>
<li>Triggerable#onEventTime</li>
</ol>
<h4 id="22-传递给-output">2.2 传递给 Output</h4>
<ol>
<li>AbstractStreamOperator#processWatermark</li>
<li>Output#emitWatermark</li>
<li>RecordWriterOutput#emitWatermark 将 watermark 推送到下游算子</li>
<li>RecordWriter#broadcastEmit 将 watermark 封装成 Record 推送到 targetPartition</li>
<li>ChannelSelectorRecordWriter#broadcastEmit 将 Record 序列化为 ByteBuffer 并推到所有 subPartitions</li>
<li>ResultPartitionWriter#emitRecord</li>
<li>BufferWritingResultPartition#emitRecord 将数据写入 Buffer</li>
<li>BufferWritingResultPartition#appendUnicastDataForRecordContinuation</li>
<li>BufferWritingResultPartition#addToSubpartition</li>
<li>ResultSubpartition#add</li>
<li>PipelinedSubpartition#add 数据写入 ResultSubpartition 的 Buffer</li>
</ol>
<h4 id="23-input-读出-watermark-localinputchannel-为例">2.3 Input 读出 Watermark （LocalInputChannel 为例）</h4>
<ol>
<li>StatusWatermarkValve#inputWatermark</li>
<li>AbstractStreamTaskNetworkInput#processElement</li>
<li>AbstractStreamTaskNetworkInput#processBuffer</li>
<li>CheckpointedInputGate#pollNext</li>
<li>InputGate#pollNext</li>
<li>SingleInputGate#pollNext</li>
<li>SingleInputGate#getNextBufferOrEvent</li>
<li>SingleInputGate#waitAndGetNextData</li>
<li>SingleInputGate#readBufferFromInputChannel</li>
<li>InputChannel#getNextBuffer</li>
<li>LocalInputChannel#getNextBuffer 从 subpartitionView 读取 Buffer</li>
<li>LocalInputChannel#requestSubpartition 从 partitionManager 获取 ResultSubpartitionView</li>
</ol>
<h4 id="24-input-输出-watermark-到下游">2.4 Input 输出 Watermark 到下游</h4>
<ol>
<li>StreamTask#processInput</li>
<li>StreamInputProcessor#processInput</li>
<li>StreamOneInputProcessor#processInput</li>
<li>PushingAsyncDataInput#emitNext</li>
<li>AbstractStreamTaskNetworkInput#emitNext</li>
<li>AbstractStreamTaskNetworkInput#processElement</li>
<li>StatusWatermarkValve#inputWatermark <br>
更新该 inputChannel 的 watermark 和 watermark aligned 状态，并更新所有 channel 的 watermark 组成的 priorityQueue 顺序</li>
<li>StatusWatermarkValve#findAndOutputNewMinWatermarkAcrossAlignedChannels <br>
将当前所有 channel 里最小的 watermark 输出到下游</li>
<li>DataOutput#emitWatermark</li>
</ol>
<h2 id="3-总结">3. 总结</h2>
<ol>
<li>数据源的 <strong>SourceReader</strong> 调用 <strong>SourceOutput</strong> 输出 record 或同时输出 rocord 和时间戳</li>
<li>如果是流式任务 <strong>SourceOperator</strong> 会用 <strong>ProgressiveTimestampsAndWatermarks</strong> 作为 eventTimeLogic，并周期性触发 <strong>WatermarkGenerator</strong> 的 <code>onPeriodicEmit</code> 方法；</li>
<li><strong>SourceOutputWithWatermarks</strong> 实现了 <strong>SourceOutput</strong> 接口，接收 record 后使用 <strong>TimestampAssigner</strong> 从 record 和传入时间戳中提取新的时间戳，并将提取的时间戳通过 <strong>WatermarkGenerator</strong> 的 <code>onEvent</code> 方法传递给 <strong>WatermarkGenerator</strong>；</li>
<li><strong>WatermarkGenerator</strong> 决定 watermark 的累积逻辑以及何时推送到下游</li>
<li>watermark 被转换成 Record 并推送到下游</li>
</ol>
<h2 id="4-关于空闲数据源和-watermark-对齐">4. 关于空闲数据源和 Watermark 对齐</h2>
<h4 id="41-空闲数据源">4.1 空闲数据源</h4>
<p>如果 Source 长时间没有数据输出，会导致 watermark 无法更新，下游依赖 watermark 更新的算子无法继续处理数据</p>
<ol>
<li>为解决这一问题，<strong>WatermarkStrategy</strong> 提供了 <code>withIdleness</code> 选项设置空闲数据源的 idle timeout duration，当超过这个时间没有数据输出时会将 <code>WatermarkStatus#IDLE_STATUS</code> 通过 <code>Output#emitWatermark</code> 传递到下游</li>
<li>如果数据源的一个或多个 partitions/splits/shards 没有数据输出，但剩余的 partitions/splits/shards 还有数据输出，<strong>CombinedWatermarkStatus</strong> 会忽略掉 idle 的 <code>partialWatermark</code>，如果所有都 idle 则会输出 <code>WatermarkStatus#IDLE_STATUS</code> 到下游</li>
<li>当下游的算子从一个 InputChannel 接收到 <code>WatermarkStatus#IDEL_STATUS</code> 时会将该 channel 设置成 <code>Unaligned</code> 状态，并忽略该 channel 之前的 watermark</li>
<li>当下游算子的所有 InputChannel 都接收到 <code>WatermarkStatus#IDLE_STATUS</code> 时，算子也进入 idle 状态并向下游发送 <code>WatermarkStatus#IDLE_STATUS</code></li>
<li>如果 Source 结束输出数据，应该往下游推 <code>Long.MAX_VALUE</code> 作为 watermark 而不是 <code>WatermarkStatus#IDLE_STATUS</code></li>
<li>所有发送过 <code>WatermarkStatus#IDLE_STATUS</code> 的算子在重新发送 <code>WatermarkStatus#ACTIVE_STATUS</code> 后就能恢复到正常工作状态</li>
</ol>
<h4 id="42-watermark-对齐">4.2 Watermark 对齐</h4>
<p>如果数据源的一个或多个 partitions/splits/shards 输出数据的速度比其他的快很多/慢很多，会导致 watermark 更新速度差距太大，下游依赖 watermark 更新的算子无法正确处理数据，比如 TumblingEventTimeWindows 缓存很多数据而不触发聚合<br>
1.</p>
		</div>
		<footer class="post__footer">
			
<div class="post__tags tags clearfix">
	<svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M4 0h8s2 0 4 2l15 15s2 2 0 4L21 31s-2 2-4 0L2 16s-2-2-2-4V3s0-3 4-3m3 10a3 3 0 0 0 0-6 3 3 0 0 0 0 6"/></svg>
	<ul class="tags__list">
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/flink/" rel="tag">Flink</a>
		</li>
	</ul>
</div>
		</footer>
	</article>
</main>

<div id="gitalk-container"></div>
<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<script>
  const gitalk = new Gitalk({
    clientID: '5e216fcfdd8cdb462b85',
    clientSecret: '10659215d325c41513a047c07f576e345e697b3b',
    repo: 'zhuxingda.github.io',
    owner: 'ZhuXingda',
    admin: ['ZhuXingda'],
    id: location.pathname, 
    distractionFreeMode: false 
  });
  (function() {
    if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
      document.getElementById('gitalk-container').innerHTML = 'Gitalk comments not available by default when the website is previewed locally.';
      return;
    }
    gitalk.render('gitalk-container');
  })();
</script>

<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/tech/flink_task_inside_source_code/" rel="prev">
			<span class="pager__subtitle">«&thinsp;上一篇</span>
			<p class="pager__title">【Flink】Flink Task 和 OperatorChain 源码</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/tech/distribute_system_protocal/" rel="next">
			<span class="pager__subtitle">下一篇&thinsp;»</span>
			<p class="pager__title">分布式协议总结</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2025 Zhu Xingda.
			<span class="footer__copyright-credits">基于 <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> 引擎和 <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> 主题</span>
		</div>
	</div>
</footer>
	</div>
<script async defer src="/js/menu.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML" async></script>
</body>
</html>