<!DOCTYPE html>
<html class="no-js" lang="zh-cn">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Flink】Flink 任务执行和部署原理 - Zhu Xingda</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="上下而求索" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">上下而求索</div>
					<div class="logo__tagline">朱兴达的个人博客</div>
				</div>
		</a>
	</div>
		
<nav class="menu">
	<button class="menu__btn" aria-haspopup="true" aria-expanded="false" tabindex="0">
		<span class="menu__btn-title" tabindex="-1">菜单</span>
	</button>
	<ul class="menu__list">
		<li class="menu__item">
			<a class="menu__link" href="/">
				
				<span class="menu__text">主页</span>
				
			</a>
		</li>
		<li class="menu__item menu__item--active">
			<a class="menu__link" href="/tech/">
				
				<span class="menu__text">技术</span>
				
			</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="/note/">
				
				<span class="menu__text">笔记本</span>
				
			</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="">
				
				<span class="menu__text">生活</span>
				
			</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="/%E5%85%B3%E4%BA%8E%E6%88%91/">
				
				<span class="menu__text">关于我</span>
				
			</a>
		</li>
	</ul>
</nav>

	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Flink】Flink 任务执行和部署原理</h1>
			<div class="post__meta meta">
<div class="meta__item-datetime meta__item">
	<svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0a14 14 0 1 1 0 28 1 1 0 0 1 0-28m0 3a3 3 0 1 0 0 22 3 3 0 0 0 0-22m1 4h-2v8.4l6.8 4.4L22 18l-6-3.8z"/></svg><time class="meta__text" datetime="2025-04-24T17:22:01&#43;08:00">2025-04-24</time></div><div class="meta__item-categories meta__item"><svg class="meta__icon icon icon-category" width="16" height="16" viewBox="0 0 16 16"><path d="m7 2 1 2h8v11H0V2z"/></svg><span class="meta__text"><a class="meta__link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/" rel="category">分布式系统</a>
	</span>
</div></div>
		</header>
		
		
		<div class="content post__content clearfix">
			<p>分析 Flink 任务完整的提交过程，主要关注在这个过程中任务的格式变化和调度执行。</p>
<h2 id="代码分析">代码分析</h2>
<h4 id="1-sql-任务解析提交">1. SQL 任务解析提交</h4>
<h6 id="11-sql-解析">1.1 SQL 解析</h6>
<ol>
<li>ParserImpl#parse</li>
<li>CalciteParser#parseSqlList： SQL -&gt; SqlNode<br>
将 SQL 转换成 calcite 的 AST 抽象语法树</li>
<li>SqlNodeConverters#convertSqlNode：SqlNode -&gt; Operation
将 SqlNode 组成的抽象语法树转换成 Flink 的 Operation</li>
<li>Planner#translate： Operation -&gt; Transformation<br>
4.1. PlannerBase#translateToRel：ModifyOperation -&gt; RelNode<br>
将 ModifyOperation 再次转换回 calcite 的查询表达式<br>
4.2. Optimizer#optimize：RelNode -&gt; RelNode<br>
利用优化器对查询表达式做优化<br>
4.3. ExecNodeGraphGenerator#generate：FlinkPhysicalRel -&gt; ExecNode -&gt; ExecNodeGraph<br>
将 RelNode 组成的查询表达式转换成 ExecNode 组成的 ExecNodeGraph<br>
4.4. PlannerBase#translateToPlan：ExecNodeGraph -&gt; List&lt;Transformation<?>&gt;<br>
将 ExecNodeGraph 转换成 Transformation</li>
<li>Executor#createPipeline：List&lt;Transformation<?>&gt; -&gt; Pipeline<br>
5.1 StreamGraphGenerator#generate：List&lt;Transformation<?>&gt; -&gt; StreamGraph</li>
</ol>
<h6 id="12-任务提交">1.2 任务提交</h6>
<ol>
<li>DefaultExecutor#executeAsync</li>
<li>StreamExecutionEnvironment#executeAsync</li>
<li>PipelineExecutor#execute</li>
<li>AbstractSessionClusterExecutor#execute 以提交任务到 Session Cluster 为例<br>
4.1 FlinkPipelineTranslator#translateToJobGraph：Pipeline -&gt; JobGraph</li>
<li>ClusterClient#submitJob</li>
<li>RestClusterClient#submitJob 将 JobGraph 序列化到文件，再将文件作为请求体通过 HTTP 发送给 JobManager</li>
</ol>
<h4 id="2-streaming-任务解析提交">2. Streaming 任务解析提交</h4>
<ol>
<li>DataStream#transform 编写 Flink Streaming 任务定义各个算子时，是在定义一个个 Transformation</li>
<li>StreamExecutionEnvironment#addOperator Transformation 被添加到 StreamExecutionEnvironment</li>
<li>StreamExecutionEnvironment#execute 将汇总的 Transformation 转换为 StreamGraph，然后提交到集群</li>
<li>PipelineExecutor#execute 后面就和 SQL 提交的流程一致了</li>
</ol>
<h4 id="3-任务调度和执行">3. 任务调度和执行</h4>
<h6 id="31-jobmaster-初始化">3.1 JobMaster 初始化</h6>
<ol>
<li>Dispatcher#createJobMasterRunner JobManager 接收请求，创建 JobManagerRunner 并启动</li>
<li>JobMasterServiceLeadershipRunner#start</li>
<li>JobMasterServiceLeadershipRunner#createNewJobMasterServiceProcess 选主之后创建 JobMasterService</li>
<li>DefaultJobMasterServiceFactory#internalCreateJobMasterService 创建 JobMaster，JobGraph 作为参数</li>
<li>SchedulerNGFactory#createInstance 创建 SchedulerNG -&gt; SchedulerBase -&gt; DefaultScheduler</li>
<li>SchedulerBase#createAndRestoreExecutionGraph：JobGraph -&gt; ExecutionGraph</li>
<li>SchedulingStrategyFactory#createInstance 创建 SchedulingStrategy，参数有 ExecutionGraph 的 SchedulingTopology 和 DefaultScheduler 本身</li>
</ol>
<h6 id="32-jobmaster-调度和执行">3.2 JobMaster 调度和执行</h6>
<ol>
<li>JobMaster#onStart 启动</li>
<li>JobMaster#startScheduling 开始调度</li>
<li>SchedulerBase#startScheduling 调度器执行调度逻辑</li>
<li>SchedulingStrategy#startScheduling SchedulingStrategy 有 PipelinedRegionSchedulingStrategy 和 VertexwiseSchedulingStrategy 两个实现，对应 streaming 任务和 batch 任务的调度策略，这里以 PipelinedRegionSchedulingStrategy 为例</li>
<li>PipelinedRegionSchedulingStrategy#startScheduling 开始调度 region，具体的调度逻辑在后文详细分析</li>
<li>PipelinedRegionSchedulingStrategy#scheduleRegion 将 SchedulingPipelinedRegion 下的 ExecutionVertexID List 分配到 Slot</li>
<li>DefaultScheduler#allocateSlotsAndDeploy 转换 ExecutionVertexID -&gt; JobVertexID -&gt; ExecutionVertex -&gt; Execution ，然后将一批 Execution List 分配到 Slot</li>
<li>DefaultExecutionDeployer#allocateSlotsAndDeploy
<ul>
<li>绑定 Slot：</li>
</ul>
<ol>
<li>DefaultExecutionDeployer#allocateSlotsFor Execution -&gt; ExecutionAttemptID ， 交由 ExecutionSlotAllocator 执行 Slot 分配</li>
<li>ExecutionSlotAllocator#allocateSlotsFor 该接口有 SimpleExecutionSlotAllocator 和 SlotSharingExecutionSlotAllocator 两个实现，后者支持将一个 ExecutionSlotSharingGroup 里的 Execution 分配到同一个 Slot 运行</li>
<li>SlotSharingExecutionSlotAllocator#allocateSlotsFor 使用 SlotSharingStrategy 将 Execution 的 ExecutionVertexID 分配到 ExecutionSlotSharingGroup，然后将 ExecutionSlotSharingGroup 绑定到 LogicalSlot</li>
</ol>
<ul>
<li>部署到 Slot：</li>
</ul>
<ol>
<li>DefaultExecutionDeployer#createDeploymentHandles 创建 ExecutionDeploymentHandle</li>
<li>DefaultExecutionDeployer#waitForAllSlotsAndDeploy -&gt; DefaultExecutionDeployer#deployAll -&gt; DefaultExecutionDeployer#deployOrHandleError -&gt; DefaultExecutionOperations#deploy -&gt; Execution#deploy</li>
</ol>
</li>
</ol>
<h4 id="4-任务格式转换">4. 任务格式转换</h4>
<h6 id="41-transformation---streamgraph">4.1 Transformation -&gt; StreamGraph</h6>
<ol>
<li>org.apache.flink.streaming.api.graph.StreamGraphGenerator#generate<br>
生成 StreamGraph，遍历 Transformation List，将每个 Transformation 转换为 StreamNode 并添加到 StreamGraph</li>
<li>org.apache.flink.streaming.api.graph.StreamGraphGenerator#transform<br>
如果有调用 SingleOutputStreamOperator#slotSharingGroup / org.apache.flink.streaming.api.datastream.DataStreamSink#slotSharingGroup 接口为 Transformation 设置 SlotSharingGroup，则将该 SlotSharingGroup 的 name 和 ResourceProfile 添加到 slotSharingGroupResources 集合中</li>
<li>org.apache.flink.streaming.api.graph.StreamGraphGenerator#translate<br>
由 TransformationTranslator 将 Transformation 转换为 StreamNode，并添加到 StreamGraph</li>
<li>org.apache.flink.streaming.api.graph.StreamGraph#addOperator
添加 StreamNode 到 StreamGraph，添加时的参数有：</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#f92672">&lt;</span>IN, OUT<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">addOperator</span>(
</span></span><span style="display:flex;"><span>            Integer vertexID,
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">@Nullable</span> String slotSharingGroup,
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">@Nullable</span> String coLocationGroup,
</span></span><span style="display:flex;"><span>            StreamOperatorFactory<span style="color:#f92672">&lt;</span>OUT<span style="color:#f92672">&gt;</span> operatorFactory,
</span></span><span style="display:flex;"><span>            TypeInformation<span style="color:#f92672">&lt;</span>IN<span style="color:#f92672">&gt;</span> inTypeInfo,
</span></span><span style="display:flex;"><span>            TypeInformation<span style="color:#f92672">&lt;</span>OUT<span style="color:#f92672">&gt;</span> outTypeInfo,
</span></span><span style="display:flex;"><span>            String operatorName,
</span></span><span style="display:flex;"><span>            Class<span style="color:#f92672">&lt;?</span> <span style="color:#66d9ef">extends</span> TaskInvokable<span style="color:#f92672">&gt;</span> invokableClass) {
</span></span><span style="display:flex;"><span>                ...
</span></span><span style="display:flex;"><span>            }
</span></span></code></pre></div><h6 id="42-streamgraph---jobgraph">4.2 StreamGraph -&gt; JobGraph</h6>
<ol>
<li>org.apache.flink.streaming.api.graph.StreamingJobGraphGenerator#createJobGraph<br>
根据 StreamGraph 创建 JobGraph</li>
<li>org.apache.flink.streaming.api.graph.StreamingJobGraphGenerator#setChaining<br>
从 StreamGraph 中的 SourceNode 开始递归地创建 JobGraph 中的全部 JobVertex</li>
<li>org.apache.flink.streaming.api.graph.StreamingJobGraphGenerator#createChain<br>
这一步将可以组成一个 Chain 的 StreamNode 合并为 OperatorChainInfo 并创建 JobVertex，这一步调用 org.StreamingJobGraphGenerator#isChainable 判断上下游算子是否可以组成 Chain</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">isChainable</span>(StreamEdge edge, StreamGraph streamGraph) {
</span></span><span style="display:flex;"><span>        StreamNode downStreamVertex <span style="color:#f92672">=</span> streamGraph.<span style="color:#a6e22e">getTargetVertex</span>(edge);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 上游只有一个输入</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> downStreamVertex.<span style="color:#a6e22e">getInEdges</span>().<span style="color:#a6e22e">size</span>() <span style="color:#f92672">==</span> 1 <span style="color:#f92672">&amp;&amp;</span> isChainableInput(edge, streamGraph);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">isChainableInput</span>(StreamEdge edge, StreamGraph streamGraph) {
</span></span><span style="display:flex;"><span>        StreamNode upStreamVertex <span style="color:#f92672">=</span> streamGraph.<span style="color:#a6e22e">getSourceVertex</span>(edge);
</span></span><span style="display:flex;"><span>        StreamNode downStreamVertex <span style="color:#f92672">=</span> streamGraph.<span style="color:#a6e22e">getTargetVertex</span>(edge);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 以下条件任一不满足则不能合并到一个 Chain</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>(<span style="color:#75715e">// 全局配置支持</span>
</span></span><span style="display:flex;"><span>                streamGraph.<span style="color:#a6e22e">isChainingEnabled</span>()
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 上游与本节点在同一个 SlotSharingGroup</span>
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">&amp;&amp;</span> upStreamVertex.<span style="color:#a6e22e">isSameSlotSharingGroup</span>(downStreamVertex)
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 节点自身支持 Chain</span>
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">&amp;&amp;</span> areOperatorsChainable(upStreamVertex, downStreamVertex, streamGraph)
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">&amp;&amp;</span> arePartitionerAndExchangeModeChainable(
</span></span><span style="display:flex;"><span>                        edge.<span style="color:#a6e22e">getPartitioner</span>(), edge.<span style="color:#a6e22e">getExchangeMode</span>(), streamGraph.<span style="color:#a6e22e">isDynamic</span>()))) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// check that we do not have a union operation, because unions currently only work</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// through the network/byte-channel stack.</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// we check that by testing that each &#34;type&#34; (which means input position) is used only once</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (StreamEdge inEdge : downStreamVertex.<span style="color:#a6e22e">getInEdges</span>()) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (inEdge <span style="color:#f92672">!=</span> edge <span style="color:#f92672">&amp;&amp;</span> inEdge.<span style="color:#a6e22e">getTypeNumber</span>() <span style="color:#f92672">==</span> edge.<span style="color:#a6e22e">getTypeNumber</span>()) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">areOperatorsChainable</span>(
</span></span><span style="display:flex;"><span>            StreamNode upStreamVertex, StreamNode downStreamVertex, StreamGraph streamGraph) {
</span></span><span style="display:flex;"><span>        StreamOperatorFactory<span style="color:#f92672">&lt;?&gt;</span> upStreamOperator <span style="color:#f92672">=</span> upStreamVertex.<span style="color:#a6e22e">getOperatorFactory</span>();
</span></span><span style="display:flex;"><span>        StreamOperatorFactory<span style="color:#f92672">&lt;?&gt;</span> downStreamOperator <span style="color:#f92672">=</span> downStreamVertex.<span style="color:#a6e22e">getOperatorFactory</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 上下游算子都不为空</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (downStreamOperator <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span> upStreamOperator <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Yielding Operator 不能和 Legacy Source 合并到同一个 Chain</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (downStreamOperator <span style="color:#66d9ef">instanceof</span> YieldingOperatorFactory
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">&amp;&amp;</span> getHeadOperator(upStreamVertex, streamGraph).<span style="color:#a6e22e">isLegacySource</span>()) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">boolean</span> isChainable;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">switch</span> (upStreamOperator.<span style="color:#a6e22e">getChainingStrategy</span>()) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 如果上游算子不支持 Chain，则不能合并到同一个 Chain</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> NEVER:
</span></span><span style="display:flex;"><span>                isChainable <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> ALWAYS:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> HEAD:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> HEAD_WITH_SOURCES:
</span></span><span style="display:flex;"><span>                isChainable <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">default</span>:
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> RuntimeException(
</span></span><span style="display:flex;"><span>                        <span style="color:#e6db74">&#34;Unknown chaining strategy: &#34;</span> <span style="color:#f92672">+</span> upStreamOperator.<span style="color:#a6e22e">getChainingStrategy</span>());
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">switch</span> (downStreamOperator.<span style="color:#a6e22e">getChainingStrategy</span>()) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 如果下游算子不支持 Chain，或者下游算子策略为 Head 则不能合并到同一个 Chain</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> NEVER:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> HEAD:
</span></span><span style="display:flex;"><span>                isChainable <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 如果下游算子策略为 ALWAYS，则取决于上游算子的 ChainingStrategy</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> ALWAYS:
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 如果下游算子策略为 HEAD_WITH_SOURCES，则取决于上游算子是否为 Source</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> HEAD_WITH_SOURCES:
</span></span><span style="display:flex;"><span>                isChainable <span style="color:#f92672">&amp;=</span> (upStreamOperator <span style="color:#66d9ef">instanceof</span> SourceOperatorFactory);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">default</span>:
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> RuntimeException(
</span></span><span style="display:flex;"><span>                        <span style="color:#e6db74">&#34;Unknown chaining strategy: &#34;</span> <span style="color:#f92672">+</span> downStreamOperator.<span style="color:#a6e22e">getChainingStrategy</span>());
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 上下游算子并行度必须一致</span>
</span></span><span style="display:flex;"><span>        isChainable <span style="color:#f92672">&amp;=</span> upStreamVertex.<span style="color:#a6e22e">getParallelism</span>() <span style="color:#f92672">==</span> downStreamVertex.<span style="color:#a6e22e">getParallelism</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 如果全局配置不支持不同最大并行度的算子合并到同一个 Chain，则上下游算子最大并行度必须一致</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>streamGraph.<span style="color:#a6e22e">isChainingOfOperatorsWithDifferentMaxParallelismEnabled</span>()) {
</span></span><span style="display:flex;"><span>            isChainable <span style="color:#f92672">&amp;=</span>
</span></span><span style="display:flex;"><span>                    upStreamVertex.<span style="color:#a6e22e">getMaxParallelism</span>() <span style="color:#f92672">==</span> downStreamVertex.<span style="color:#a6e22e">getMaxParallelism</span>();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> isChainable;
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><ol start="4">
<li>org.apache.flink.streaming.api.graph.StreamingJobGraphGenerator#createJobVertex<br>
根据 OperatorChainInfo 创建 JobVertex，并添加到 JobGraph</li>
</ol>
<h6 id="43-jobgraph---executiongraph">4.3 JobGraph -&gt; ExecutionGraph</h6>
<ol>
<li>org.apache.flink.runtime.executiongraph.DefaultExecutionGraphBuilder#buildGraph<br>
根据 JobGraph 创建 ExecutionGraph<br>
<img src="https://nightlies.apache.org/flink/flink-docs-master/fig/job_and_execution_graph.svg"></li>
</ol>
<h2 id="总结">总结</h2>
<h4 id="1-任务格式">1. 任务格式</h4>
<h6 id="11-任务格式演变">1.1 任务格式演变</h6>
<ol>
<li>SQL 任务：<br>
SQL -&gt; SqlNode -&gt; Operation -&gt; RelNode -&gt; ExecNode -&gt; ExecNodeGraph -&gt; Transformation -&gt; StreamGraph -&gt; JobGraph -&gt; ExecutionGraph</li>
<li>Streaming 任务：<br>
Transformation -&gt; StreamGraph -&gt; JobGraph -&gt; ExecutionGraph</li>
</ol>
<h6 id="12-任务格式结构">1.2 任务格式结构</h6>
<ol>
<li>StreamGraph<br>
StreamGraph 是原始的逻辑计划，由 StreamNode 组成，每个 StreamNode 对应一个 StreamOperator</li>
<li>JobGraph<br>
JobGraph 是经过优化后的逻辑计划，由 JobVertex 组成</li>
<li>ExecutionGraph<br>
ExecutionGraph 是执行计划，由 ExecutionJobVertex 组成</li>
</ol>
<h4 id="2-任务调度执行">2. 任务调度执行</h4>
<h6 id="21-注册-slotsharinggroup">2.1 注册 SlotSharingGroup</h6>
<p>Flink 提供了</p>
<ol>
<li>StreamExecutionEnvironment#registerSlotSharingGroup 接口用于注册 SlotSharingGroup</li>
<li>SingleOutputStreamOperator#slotSharingGroup / org.apache.flink.streaming.api.datastream.DataStreamSink#slotSharingGroup 接口用于设置 Operator 所属的 SlotSharingGroup<br>
官方提供的示例：https://nightlies.apache.org/flink/flink-docs-master/docs/deployment/finegrained_resource/#usage</li>
</ol>
<h6 id="22-构建-streamgraph-时设置-slotsharinggroup-和-colocationgroup">2.2 构建 StreamGraph 时设置 SlotSharingGroup 和 CoLocationGroup</h6>
<p>StreamGraph 中的 StreamNode 在 StreamGraph#addOperator 方法中被创建和添加到 StreamGraph，添加时会设置 SlotSharingGroup 和 CoLocationGroup：</p>
<ul>
<li>SlotSharingGroup 来自 StreamGraphGenerator#translate 执行时传入 TransformationTranslator.Context 中的 SlotSharingGroup，具体用哪个 SlotSharingGroup 由 <code>StreamGraphGenerator#determineSlotSharingGroup</code> 决定</li>
<li>CoLocationGroup 由 <code>Transformation 的 coLocationGroupKey</code> 决定，目前（Flink V2.0）该功能还没有支持</li>
</ul>
<h6 id="23-构建-jobgraph-时设置-slotsharinggroup">2.3 构建 JobGraph 时设置 SlotSharingGroup</h6>
<ol>
<li>org.apache.flink.streaming.api.graph.StreamingJobGraphGenerator#createJobGraph<br>
根据 StreamGraph 创建 JobGraph，创建过程中会设置 SlotSharingGroup 和 CoLocationGroup</li>
<li>org.apache.flink.streaming.api.graph.StreamingJobGraphGenerator#setSlotSharing</li>
</ol>
		</div>
		<footer class="post__footer">
			
<div class="post__tags tags clearfix">
	<svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M4 0h8s2 0 4 2l15 15s2 2 0 4L21 31s-2 2-4 0L2 16s-2-2-2-4V3s0-3 4-3m3 10a3 3 0 0 0 0-6 3 3 0 0 0 0 6"/></svg>
	<ul class="tags__list">
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/flink/" rel="tag">Flink</a>
		</li>
	</ul>
</div>
		</footer>
	</article>
</main>

<div id="gitalk-container"></div>
<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<script>
  const gitalk = new Gitalk({
    clientID: '5e216fcfdd8cdb462b85',
    clientSecret: '10659215d325c41513a047c07f576e345e697b3b',
    repo: 'zhuxingda.github.io',
    owner: 'ZhuXingda',
    admin: ['ZhuXingda'],
    id: location.pathname, 
    distractionFreeMode: false 
  });
  (function() {
    if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
      document.getElementById('gitalk-container').innerHTML = 'Gitalk comments not available by default when the website is previewed locally.';
      return;
    }
    gitalk.render('gitalk-container');
  })();
</script>

<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/tech/data_storage_file_format/" rel="prev">
			<span class="pager__subtitle">«&thinsp;上一篇</span>
			<p class="pager__title">ORC 和 Parquet 文件格式</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/tech/tcpdump_usage_notebook/" rel="next">
			<span class="pager__subtitle">下一篇&thinsp;»</span>
			<p class="pager__title">【Linux】Linux 服务器抓包记录</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2025 Zhu Xingda.
			<span class="footer__copyright-credits">基于 <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> 引擎和 <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> 主题</span>
		</div>
	</div>
</footer>
	</div>
<script async defer src="/js/menu.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML" async></script>
</body>
</html>