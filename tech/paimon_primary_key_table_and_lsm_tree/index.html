<!DOCTYPE html>
<html class="no-js" lang="zh-cn">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Paimon】Paimon 主键表和 LSM Tree - Zhu Xingda</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="上下而求索" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">上下而求索</div>
					<div class="logo__tagline">朱兴达的个人博客</div>
				</div>
		</a>
	</div>
		
<nav class="menu">
	<button class="menu__btn" aria-haspopup="true" aria-expanded="false" tabindex="0">
		<span class="menu__btn-title" tabindex="-1">菜单</span>
	</button>
	<ul class="menu__list">
		<li class="menu__item">
			<a class="menu__link" href="/">
				
				<span class="menu__text">主页</span>
				
			</a>
		</li>
		<li class="menu__item menu__item--active">
			<a class="menu__link" href="/tech/">
				
				<span class="menu__text">技术</span>
				
			</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="/note/">
				
				<span class="menu__text">笔记本</span>
				
			</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="">
				
				<span class="menu__text">生活</span>
				
			</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="/%E5%85%B3%E4%BA%8E%E6%88%91/">
				
				<span class="menu__text">关于我</span>
				
			</a>
		</li>
	</ul>
</nav>

	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Paimon】Paimon 主键表和 LSM Tree</h1>
			<div class="post__meta meta">
<div class="meta__item-datetime meta__item">
	<svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0a14 14 0 1 1 0 28 1 1 0 0 1 0-28m0 3a3 3 0 1 0 0 22 3 3 0 0 0 0-22m1 4h-2v8.4l6.8 4.4L22 18l-6-3.8z"/></svg><time class="meta__text" datetime="2025-02-19T14:37:57&#43;08:00">2025-02-19</time></div><div class="meta__item-categories meta__item"><svg class="meta__icon icon icon-category" width="16" height="16" viewBox="0 0 16 16"><path d="m7 2 1 2h8v11H0V2z"/></svg><span class="meta__text"><a class="meta__link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/" rel="category">分布式系统</a>
	</span>
</div></div>
		</header>
		
		
		<div class="content post__content clearfix">
			<p>Paimon 以数据表是否有主键，将表分为 <code>Append Only Table</code> 和 <code>Primary Key Table</code>，对数据的操作前者只支持 Insert，后者还支持 Update 和 Delete，本文主要分析 Paimon 主键表的结构和实现原理</p>
<h2 id="lsm-tree-原理">LSM Tree 原理</h2>
<p><a href="https://www.cs.umb.edu/~poneil/lsmtree.pdf">论文原文</a> <br>
Log Structured Merge Tree 是一种为解决大规模数据写入瓶颈的数据存储结构，其核心是利用磁盘的顺序写在性能上优于随机写这一特点，将批量的随机写转换为一次顺序写，适当牺牲读性能的情况下提升写数据的性能，LSM Tree 被广泛应用于 LevelDB、HBase、Iceberg、RocksDB、Paimon 等分布式数据库</p>
<h4 id="基本结构">基本结构</h4>
<ol>
<li>LSM Tree 的基本结构由 L0、L1 &hellip; Ln 多个 Level 组成，其中 L0 在内存，L1 至 Ln 在磁盘</li>
<li>L0 采用一种排序算法来保持数据按 Key 有序排列，例如红黑树、AVL 树、跳表、TreeMap 等</li>
<li>每一颗子树中的数据量在超过一定阈值后会执行合并，结果被写入下一颗子树</li>
<li>L1 至 Ln 中的数据只是按 Key 顺序保存于磁盘，并不维护排序的数据结构，同一 Level 中的多个数据文件中的 key 范围不相交，也称一层 Level 为一个 Sorted Run</li>
<li>只有 L0 中的数据支持原地更新，其余子树中的数据更新采用追加写</li>
</ol>
<h4 id="基本操作">基本操作</h4>
<h6 id="写入操作">写入操作</h6>
<p>数据直接被写入内存中的 L0 ，按 Key 插入数据结构中的对应位置，如果该 Key 对应的数据在 L0 中已存在则直接被新数据覆盖，写入操作的时间复杂度为 <code>O(logn)</code></p>
<h6 id="删除操作">删除操作</h6>
<p>删除数据时存在三种情况：</p>
<ol>
<li><strong>被删除的数据在 L0</strong><br>
则将 L0 中的该数据置为 <code>DELETED</code> 状态，在下一次 L0 合并时被写入 L1。这里不是直接将该数据从 L0 中移除的原因是这条数据可能已经存在于后面的子树中，如果直接移除并不会对后面子树中的这条数据产生影响，同时按照后文查询时的逻辑还会造成被删除的数据被查询到</li>
<li><strong>被删除的数据在 L1 - Ln</strong><br>
不对 L1 - Ln 中的数据做修改，而是直接在 L0 中插入一条 <code>DELETED</code> 状态的该数据，后续该数据传到 L1 - Ln 后会在合并时覆盖掉原有的数据</li>
<li><strong>被删除的数据不存在</strong><br>
同样在 L0 中插入一条 <code>DELETED</code> 状态的该数据<br>
综上三种情况执行删除都是在 L0 中操作，其时间复杂度为 <code>O(logn)</code></li>
</ol>
<h6 id="更新操作">更新操作</h6>
<p>更新操作同删除操作一样也是三种情况：</p>
<ol>
<li><strong>被更新的数据在 L0</strong><br>
直接覆盖更新 L0 中的旧数据</li>
<li><strong>被更新的数据在 L1 - Ln</strong><br>
不对 L1 - Ln 中的数据做修改，而是直接将新的数据插入 L0，后续该数据传到 L1 - Ln 后会在合并时覆盖掉原有的数据</li>
<li><strong>被更新的数据不存在</strong><br>
同样直接在 L0 中插入新数据<br>
综上三种情况执行更新都是在 L0 中操作，其时间复杂度为 <code>O(logn)</code></li>
</ol>
<h6 id="合并操作">合并操作</h6>
<p>各子树中的数据量在达到阈值后，需要执行<code>合并（Compact）</code>操作：</p>
<ol>
<li><strong>L0 合并</strong>
L0 执行合并时直接将有序数据写入 L1 的一个新的 SST文件（磁盘上实际保存数据的文件）</li>
<li><strong>L1 - Ln 合并（以L1为例）</strong>
<ul>
<li>L1 - Ln 执行合并时，新旧两个 SST 文件的 key 范围相交，因为新旧两个 SST 都是有序的所以每个子树合并的时间复杂度为 <code>O(n)</code></li>
<li>两个 SST 合并时相同 Key 对应的数据由新 SST 中的替代旧 SST 中的</li>
</ul>
</li>
</ol>
<h6 id="查询操作">查询操作</h6>
<p>查询时按照 L0 - Ln 的顺序从各子树中逐级查询，一旦查到则直接返回。这样保证了查到的数据一定是最新版本的数据</p>
<ol>
<li><strong>被查询的数据在 L0</strong>
直接利用 L0 的数据结构查询数据，时间复杂度 <code>O(logn)</code></li>
<li><strong>被查询的数据在 L1 - Ln</strong>
目标数据在 L0 没有查到逐级查询 L1 - Ln，如果没有任何索引用二分查找每一级时间复杂度 <code>O(logn)</code>，也可以在 L1 - Ln 建立稀疏矩阵来减少 IO 次数加速查询</li>
</ol>
<h4 id="特点">特点</h4>
<p>从基本操作可以看到 LSM Tree 的增删改操作都在内存执行，然后利用磁盘顺序读写合并来逐级消除数据冲突，适用于大量数据的导入。在查询上 LSM Tree 需要逐级查找，与 B+ 树 O(logn) 的查询速度相比没有优势。</p>
<h4 id="paimon-的-lsm-tree-结构">Paimon 的 LSM Tree 结构</h4>
<p><a href="https://github.com/facebook/rocksdb/wiki/Universal-Compaction">RocksDB Universal Compaction 文档</a><br>
上述 LSM Tree 的结构被称为 Leveled Compaction，除此之外 RocksDB 还提出了另一种称为 Universal Compaction 的结构：</p>
<ul>
<li>该结构中数据按 Sorted Run 划分，每个 Sorted Run 中的 SST 文件对应一个时间范围内产生的数据，各 Sorted Runs 的时间范围不相交</li>
<li>执行 Compact 时时间范围相邻的 Sort Runs 中的 SST 文件合并到一起，新产生的文件尽可能放到旧的 Sorted Run 中（但要满足各 Sorted Runs 的时间范围不相交的条件）</li>
</ul>
<p>Paimon 的 LSM Tree 也采用 Universal Compaction 结构，Level0 的每个数据文件单独是一个 Sorted Run，其余每个 Level 是一个 Sorted Run</p>
<h2 id="paimon-代码分析">Paimon 代码分析</h2>
<h4 id="1-主键表数据写入和触发-compaction">1. 主键表数据写入和触发 Compaction</h4>
<p>Flink 数据流从 <code>org.apache.paimon.flink.sink.FlinkSink#doWrite</code> 方法传入，经过：</p>
<ul>
<li>org.apache.paimon.flink.sink.RowDataStoreWriteOperator#processElement</li>
<li>org.apache.paimon.flink.sink.StoreSinkWriteImpl#write</li>
<li>org.apache.paimon.table.sink.TableWriteImpl#writeAndReturn
进入 Paimon 的数据表写入逻辑，根据 主键表/非主键表 + Bucket Mode 对应不同的 MemoryFileStoreWrite 的实现类：</li>
<li>KeyValueFileStoreWrite</li>
<li>AppendOnlyUnawareBucketFileStoreWrite</li>
<li>AppendOnlyFixedBucketFileStoreWrite</li>
<li>PostponeBucketFileStoreWrite
<code>KeyValueFileStoreWrite</code> 对应主键表，与其对应的 RecordWriter 接口实现是 <code>MergeTreeWriter</code>，CompactManager 接口实现是 <code>MergeTreeCompactManager</code></li>
</ul>
<p><code>MergeTreeWriter</code> 将传入的 record 缓存在 WriteBuffer，缓存满后调用 flushWriteBuffer 方法将数据落盘，然后将新增的这一批数据文件的元信息添加到 <code>MergeTreeCompactManager</code> 的 Level0，并触发 <code>MergeTreeCompactManager</code> Universal Compaction（非 Full Compaction）</p>
<h4 id="2-主键表执行-compaction">2. 主键表执行 Compaction</h4>
<p><code>MergeTreeCompactManager#triggerCompaction</code> 方法进入 Compaction 的流程，一共有 Full Compaction 和 Universal Compaction 两种模式</p>
<ul>
<li>Full Compaction 将所有 Sorted Runs 合并到最高 Level 对应的 Sorted Run</li>
<li>Universal Compaction 包含 1. Compact Level 0 的全部 Sorted Runs 2. Compact Level 0 ～ Level n-1 的 Sorted Runs 3. Full Compaction 三种情况</li>
</ul>
<p>Universal Compaction 从 <code>CompactStrategy#pick</code> 接口获取 Compact 的数据文件，有 UniversalCompaction 和 ForceUpLevel0Compaction 两个实现，其中 ForceUpLevel0Compaction 会先执行 UniversalCompaction，如果没有 pick 到 Sorted Runs 则强制 Level 0 的 Sorted Runs Compact</p>
<h6 id="universalcompaction-的-pick-策略">UniversalCompaction 的 pick 策略</h6>
<ol>
<li>是否触发 Optimized Compaction<br>
如果开启了 <code>compaction.optimization-interval</code> 会周期性触发 optimization full compation 来保障 <a href="https://paimon.apache.org/docs/1.1/concepts/system-tables/#read-optimized-table">optimized table</a> 的时效性，Full Compation 会将所有 Sorted Run 都 compat 到最高 Level 对应的 Sorted Run</li>
<li>是否需要减小空间放大<br>
如果以下条件满足则触发一次 Full Compaction
<blockquote>
<p><code>当前全部数据文件的 size</code> / <code>Highest Level 数据文件的 size</code> * 100 &gt; <code>compaction.max-size-amplification-percent</code></p>
</blockquote>
</li>
<li>是否有 Sorted Run 满足 Size Ratio
从 L0 的第一个 Sorted Runs 开始遍历，累加每个 Sorted Runs 数据文件的 total size，当 total size 满足条件时合并对应的 Sorted Runs
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @param maxLevel Higest Level
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @param runs 所有 Sorted Runs
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @param candidateCount 这里是 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @param forcePick 这里是 false
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> CompactUnit <span style="color:#a6e22e">pickForSizeRatio</span>(
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> maxLevel, List<span style="color:#f92672">&lt;</span>LevelSortedRun<span style="color:#f92672">&gt;</span> runs, <span style="color:#66d9ef">int</span> candidateCount, <span style="color:#66d9ef">boolean</span> forcePick) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// candidateCount 为 1，candidateSize 即第一个 Sorted Run 的 total size</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">long</span> candidateSize <span style="color:#f92672">=</span> candidateSize(runs, candidateCount);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 按 Level0 ~ Higest Level 遍历所有 Sorted Run</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> candidateCount; i <span style="color:#f92672">&lt;</span> runs.<span style="color:#a6e22e">size</span>(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            LevelSortedRun next <span style="color:#f92672">=</span> runs.<span style="color:#a6e22e">get</span>(i);
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// sizeRatio 由 &#39;compaction.size-ratio&#39; 配置项决定，假设这里是默认值 1</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 如果 下一个 Sorted Run 的 total size 比当前累加的 total size 大超过 1% 则停止累加</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (candidateSize <span style="color:#f92672">*</span> (100.<span style="color:#a6e22e">0</span> <span style="color:#f92672">+</span> sizeRatio) <span style="color:#f92672">/</span> 100.<span style="color:#a6e22e">0</span> <span style="color:#f92672">&lt;</span> next.<span style="color:#a6e22e">run</span>().<span style="color:#a6e22e">totalSize</span>()) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            candidateSize <span style="color:#f92672">+=</span> next.<span style="color:#a6e22e">run</span>().<span style="color:#a6e22e">totalSize</span>();
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// candidateCount 记录需要被 compact 的 Sorted Runs</span>
</span></span><span style="display:flex;"><span>            candidateCount<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (forcePick <span style="color:#f92672">||</span> candidateCount <span style="color:#f92672">&gt;</span> 1) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> createUnit(runs, maxLevel, candidateCount);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@VisibleForTesting</span>
</span></span><span style="display:flex;"><span>    CompactUnit <span style="color:#a6e22e">createUnit</span>(List<span style="color:#f92672">&lt;</span>LevelSortedRun<span style="color:#f92672">&gt;</span> runs, <span style="color:#66d9ef">int</span> maxLevel, <span style="color:#66d9ef">int</span> runCount) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> outputLevel;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (runCount <span style="color:#f92672">==</span> runs.<span style="color:#a6e22e">size</span>()) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Full Compaction</span>
</span></span><span style="display:flex;"><span>            outputLevel <span style="color:#f92672">=</span> maxLevel;
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Next Sorted Run 对应 Level - 1</span>
</span></span><span style="display:flex;"><span>            outputLevel <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">max</span>(0, runs.<span style="color:#a6e22e">get</span>(runCount).<span style="color:#a6e22e">level</span>() <span style="color:#f92672">-</span> 1);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (outputLevel <span style="color:#f92672">==</span> 0) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 如果需要压缩的 Sorted Runs 都在 Level 0，则把所有 Level 0 的 Sorted Runs 都压缩到下一个 Level</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> runCount; i <span style="color:#f92672">&lt;</span> runs.<span style="color:#a6e22e">size</span>(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>                LevelSortedRun next <span style="color:#f92672">=</span> runs.<span style="color:#a6e22e">get</span>(i);
</span></span><span style="display:flex;"><span>                runCount<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (next.<span style="color:#a6e22e">level</span>() <span style="color:#f92672">!=</span> 0) {
</span></span><span style="display:flex;"><span>                    outputLevel <span style="color:#f92672">=</span> next.<span style="color:#a6e22e">level</span>();
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 如果是 Full Compaction 更新前面 Optimized Compaction 执行的时间，避免重复 Full Compaction</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (runCount <span style="color:#f92672">==</span> runs.<span style="color:#a6e22e">size</span>()) {
</span></span><span style="display:flex;"><span>            updateLastOptimizedCompaction();
</span></span><span style="display:flex;"><span>            outputLevel <span style="color:#f92672">=</span> maxLevel;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 最终有三种 Compact 情况：</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 1. 将 Level 0 的所有 Sorted Runs Compact 到下一个 Level 的 Sorted Run</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 2. 将 Level 0 ～ Level n-1 的所有 Sorted Runs Compact 到 Level n 的 Sorted Run</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 3. Full Compaction</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> CompactUnit.<span style="color:#a6e22e">fromLevelRuns</span>(outputLevel, runs.<span style="color:#a6e22e">subList</span>(0, runCount));
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div></li>
<li>是否需要控制 Sorted Runs 数量<br>
如果当前 Sorted Runs 的数量比配置项<code>num-sorted-run.compaction-trigger</code>大 n ，则将 n 作为 candidateCount 参数，调用 <code>UniversalCompaction#pickForSizeRatio</code> 方法得到需要被 Compact 的 Sorted Runs<br>
和条件 3 相比条件 4 像是对条件 3 的兜底，比如 Level 0 的前两个 Sorted Runs 恰好导致条件 3 的 candidateCount 小于 2，Level 0 的 Compact 就会不触发</li>
<li>是否需要强制 Compact Level 0 的 Sorted Runs<br>
当主键表开启 LookUp ChangeLog Producer 或者 First Row MergeEngine 或者 Deletion Vectors 或者 &lsquo;forece-lookup&rsquo; 配置为 True，且 &rsquo;lookup-compact&rsquo; 配置为 &lsquo;gentle&rsquo; 时，如果前面 4 个条件都没有触发，则会为了 Lookup Compact 周期性地触发 Level 0 的 Sorted Runs Compact。</li>
</ol>
<h6 id="compact-具体的执行过程">Compact 具体的执行过程</h6>
<p>前面的过程是挑选出需要执行 Compact 的 CompactUnit，然后将其提交给 <code>MergeTreeCompactTask</code> 异步执行具体的合并<br>
<code>CompactRewriter</code> 负责重写 Compact 后的数据文件，接口有多个实现，<code>MergeTreeCompactRewriter</code> 实际执行数据文件合并的 Writer，FullChangelogMergeTreeCompactRewriter 和 LookupMergeTreeCompactRewriter 在 MergeTreeCompactRewriter 的基础上增加写 changlog 的逻辑<br>
MergeTreeCompactRewriter 执行数据文件合并时先用 <code>MergeTreeReaders</code> 从 Sorted Runs 读取数据文件，然后将读入的数据合并后写到 Output Level 对应 Sorted Run 的新数据文件，文件类型为 <code>FileSource.COMPACT</code></p>
<h4 id="3-读取主键表">3. 读取主键表</h4>
<p>合并过程在读取时完成，首先将不同 Sorted Runs 的数据做排序，然后对相同 key 的数据做 merge，这部分涉及的逻辑和模式比较多，单独放到 <a href="tech/paimon_primary_key_table_read">【Paimon】Paimon 主键表数据读取逻辑分析</a> 一文描述</p>
<h4 id="问题">问题</h4>
<h6 id="1-面试遇到的问题写入数据时一个-subtask-可能会被分到不同-partition-和-bucket-的数据如何将-buffer-划分给这些数据">1. 面试遇到的问题：写入数据时一个 SubTask 可能会被分到不同 partition 和 bucket 的数据，如何将 Buffer 划分给这些数据？</h6>
<p>在 <code>AbstractFileStoreWrite</code> 里会按 partition 和 bucket 将数据分给不同的 <code>WriterContainer</code> ，由 container 里的 <code>RecordWriter</code> 负责写到 Buffer 和落盘</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">abstract</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AbstractFileStoreWrite</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">implements</span> FileStoreWrite<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">write</span>(BinaryRow partition, <span style="color:#66d9ef">int</span> bucket, T data) <span style="color:#66d9ef">throws</span> Exception {
</span></span><span style="display:flex;"><span>        WriterContainer<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> container <span style="color:#f92672">=</span> getWriterWrapper(partition, bucket);
</span></span><span style="display:flex;"><span>        container.<span style="color:#a6e22e">writer</span>.<span style="color:#a6e22e">write</span>(data);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (container.<span style="color:#a6e22e">indexMaintainer</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span>) {
</span></span><span style="display:flex;"><span>            container.<span style="color:#a6e22e">indexMaintainer</span>.<span style="color:#a6e22e">notifyNewRecord</span>(data);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>AbstractFileStoreWrite 的实现类 MemoryFileStoreWrite 在创建 <code>RecordWriter</code> 后会调用 <code>MemoryPoolFactory</code> 给 <code>RecordWriter</code> 分配一个 <code>MemorySegmentPool</code> 作为 Buffer，这个 Pool 由 MemoryFileStoreWrite 的 MemorySegmentPool 封装而来，RecordWriter 在使用 Buffer 时由被封装的这个 Pool 实际负责提供 <code>MemorySegment</code></p>
<p><strong>结论</strong>：同一 SubTask 下分属不同 partition 和 bucket 的 RecordWriter 共用同一个 MemoryPool 作为 Buffer，但在使用时各自维护自己的 MemorySegment</p>
		</div>
		<footer class="post__footer">
			
<div class="post__tags tags clearfix">
	<svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M4 0h8s2 0 4 2l15 15s2 2 0 4L21 31s-2 2-4 0L2 16s-2-2-2-4V3s0-3 4-3m3 10a3 3 0 0 0 0-6 3 3 0 0 0 0 6"/></svg>
	<ul class="tags__list">
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/paimon/" rel="tag">Paimon</a>
		</li>
	</ul>
</div>
		</footer>
	</article>
</main>

<div id="gitalk-container"></div>
<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<script>
  const gitalk = new Gitalk({
    clientID: '5e216fcfdd8cdb462b85',
    clientSecret: '10659215d325c41513a047c07f576e345e697b3b',
    repo: 'zhuxingda.github.io',
    owner: 'ZhuXingda',
    admin: ['ZhuXingda'],
    id: location.pathname, 
    distractionFreeMode: false 
  });
  (function() {
    if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
      document.getElementById('gitalk-container').innerHTML = 'Gitalk comments not available by default when the website is previewed locally.';
      return;
    }
    gitalk.render('gitalk-container');
  })();
</script>

<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/tech/paimon_sink_clustring/" rel="prev">
			<span class="pager__subtitle">«&thinsp;上一篇</span>
			<p class="pager__title">【Paimon】Paimon 表排序</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/tech/kubernetes_deploy_nodebook/" rel="next">
			<span class="pager__subtitle">下一篇&thinsp;»</span>
			<p class="pager__title">【Kubernetes】记录一些在使用 Kubernetes 时遇到的问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2025 Zhu Xingda.
			<span class="footer__copyright-credits">基于 <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> 引擎和 <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> 主题</span>
		</div>
	</div>
</footer>
	</div>
<script async defer src="/js/menu.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML" async></script>
</body>
</html>